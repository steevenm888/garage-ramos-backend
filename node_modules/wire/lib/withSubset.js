'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = withSubset;

var _castFilemap = require('./castFilemap');

var _castFilemap2 = _interopRequireDefault(_castFilemap);

var _compose = require('./compose');

var _compose2 = _interopRequireDefault(_compose);

var _createMatcher = require('./createMatcher');

var _createMatcher2 = _interopRequireDefault(_createMatcher);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// import type { Matchable, Transform, AsyncTransform } from './t'

/**
 * Creates an asynchronous transform that will apply the given `transforms` to only a subset of
 * incoming files. Files outside this subset are kept aside and then recombined with the output
 * files at the end before finally returning them.
 */

function withSubset(pattern, ...transforms) {
  if (!transforms.length) return async files => files;

  // precompile a matcher for repeat unselected
  const match = (0, _createMatcher2.default)(pattern);

  // compose the passed transforms into a single transform
  const transform = (0, _compose2.default)(...transforms);

  // return a transform that only operates on files that match the matcher
  return async files => {
    const filesObject = (0, _castFilemap2.default)(files).toObject();
    const names = Object.keys(filesObject);
    const count = names.length;

    // sort them into selected and unselected
    const selectedFiles = {};
    const unselectedFiles = {};
    for (let i = 0; i < count; i += 1) {
      const name = names[i];
      const group = match(name) ? selectedFiles : unselectedFiles;
      group[name] = filesObject[name];
    }

    // transform the selected subset
    const selectedOutput = await transform(selectedFiles);

    // merge the unselected files into the output
    return (0, _castFilemap2.default)(selectedOutput.merge(unselectedFiles));
  };
}